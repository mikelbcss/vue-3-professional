Refactoriza este carrito de compras para usar `computed()` en lugar de sincronizaciÃ³n manual de estado.

## ğŸš¨ Problema Actual

El componente actual tiene un **anti-patrÃ³n**: sincroniza manualmente las estadÃ­sticas del carrito llamando `updateCartStatistics()` despuÃ©s de cada operaciÃ³n. Esto es propenso a errores y difÃ­cil de mantener.

## CÃ³digo Actual (Con Problemas)

```vue
<script setup lang="ts">
import { ref } from 'vue'

const items = ref([...])

// âŒ PROBLEMA: Estado sincronizado manualmente
const totalItems = ref(4)
const uniqueItemsCount = ref(3)
const totalPrice = ref(1124)
const averagePrice = ref(374.67)
const hasExpensiveItems = ref(true)
const cartStatus = ref('Carrito con productos')

// âŒ PROBLEMA: FunciÃ³n que debe llamarse en cada operaciÃ³n
const updateCartStatistics = () => {
  totalItems.value = items.value.reduce((sum, item) => sum + item.quantity, 0)
  uniqueItemsCount.value = items.value.length
  totalPrice.value = items.value.reduce((sum, item) => sum + (item.price * item.quantity), 0)
  // ... mÃ¡s cÃ¡lculos manuales
}

const incrementQuantity = (id: number) => {
  // ... lÃ³gica
  updateCartStatistics() // âŒ Â¡FÃ¡cil de olvidar!
}

const addItem = () => {
  // ... lÃ³gica
  updateCartStatistics() // âŒ Â¡Repetitivo y propenso a errores!
}
</script>
```

## ğŸ¯ Tu Tarea

Convierte todas las estadÃ­sticas del carrito de **refs manuales** a **computed properties** que se actualicen automÃ¡ticamente:

### EstadÃ­sticas a convertir:

1. **`totalItems`**: Total de productos en el carrito (suma de cantidades)
2. **`uniqueItemsCount`**: NÃºmero de artÃ­culos Ãºnicos
3. **`totalPrice`**: Precio total del carrito
4. **`averagePrice`**: Precio promedio por tipo de producto
5. **`hasExpensiveItems`**: Si hay productos > â‚¬50
6. **`cartStatus`**: Estado del carrito basado en contenido y precio

### Pasos a seguir:

1. **Importa `computed`** desde 'vue'
2. **Convierte cada `ref()` a `computed()`** con la lÃ³gica apropiada
3. **Elimina la funciÃ³n `updateCartStatistics()`** completamente
4. **Remueve todas las llamadas** a `updateCartStatistics()`
5. **Verifica que todo funcione** automÃ¡ticamente

## âœ¨ Beneficios de `computed()`

- **AutomÃ¡tico**: Se actualiza solo cuando cambian las dependencias
- **Eficiente**: Solo recalcula cuando es necesario (cache inteligente)
- **Sin errores**: No puedes olvidar actualizar el estado
- **Declarativo**: El cÃ³digo expresa _quÃ©_ quieres, no _cÃ³mo_ actualizarlo
- **Limpio**: Eliminas cÃ³digo repetitivo de sincronizaciÃ³n

## ğŸ” Conceptos Clave

### Computed vs Ref para Estado Derivado

```js
// âŒ Manual: Propenso a errores
const total = ref(0)
const updateTotal = () => {
  total.value = items.value.reduce((sum, item) => sum + item.price, 0)
}

// âœ… Computed: AutomÃ¡tico y confiable
const total = computed(() => {
  return items.value.reduce((sum, item) => sum + item.price, 0)
})
```

### Dependencias Reactivas

Los computed properties rastrea automÃ¡ticamente sus dependencias:

```js
const cartStatus = computed(() => {
  // Vue rastrea que depende de items.value y totalPrice.value
  if (items.value.length === 0) return 'Carrito vacÃ­o'
  if (totalPrice.value > 500) return 'Carrito premium'
  return 'Carrito con productos'
})
```

## ğŸ’¡ Pistas

- Cada computed debe retornar un valor calculado basado en `items.value`
- Usa mÃ©todos de array como `reduce()`, `length`, `some()`
- Para el precio promedio: `totalPrice / uniqueItemsCount` (cuidado con divisiÃ³n por cero)
- Para estado del carrito: usa condicionales basadas en longitud y precio total
- Los computed properties se usan igual que refs en el template

## ğŸš€ Resultado Esperado

DespuÃ©s de la refactorizaciÃ³n:

- âœ… Sin funciÃ³n `updateCartStatistics()`
- âœ… Sin llamadas manuales de actualizaciÃ³n
- âœ… Todas las estadÃ­sticas como `computed()`
- âœ… ActualizaciÃ³n automÃ¡tica al cambiar items
- âœ… CÃ³digo mÃ¡s limpio y mantenible
